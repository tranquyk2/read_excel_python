import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
import pandas as pd
import requests
import os
import time
import threading
import configparser
from datetime import datetime
import json
import re
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler


class ExcelToDBApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Excel to Database Sync Tool")
        self.root.geometry("800x600")

        # Kh·ªüi t·∫°o bi·∫øn
        self.config = configparser.ConfigParser()
        self.load_config()

        self.is_running = False
        self.observer = None
        self.processed_files = {}

        # Th·ªëng k√™
        self.total_files_processed = 0
        self.total_barcodes_uploaded = 0
        self.total_errors = 0

        self.setup_ui()
        
    def load_config(self):
        """Load c·∫•u h√¨nh t·ª´ file config.ini"""
        if os.path.exists('config.ini'):
            self.config.read('config.ini')
        else:
            # T·∫°o config m·∫∑c ƒë·ªãnh
            self.config['network'] = {
                'API_URL': 'http://192.168.100.252:86/api',
                'X_API_KEY': 'project_power_2025'
            }
            self.config['settings'] = {
                'EXCEL_FOLDER_PATH': '',
                'POLLING_INTERVAL': '5'
            }
            self.save_config()
    
    def save_config(self):
        """L∆∞u c·∫•u h√¨nh v√†o file"""
        with open('config.ini', 'w') as configfile:
            self.config.write(configfile)
    
    def setup_ui(self):
        """T·∫°o giao di·ªán ng∆∞·ªùi d√πng"""
        # Main frame
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # C·∫•u h√¨nh
        config_frame = ttk.LabelFrame(main_frame, text="C·∫•u h√¨nh", padding="10")
        config_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        # API URL
        ttk.Label(config_frame, text="API URL:").grid(row=0, column=0, sticky=tk.W)
        self.api_url_var = tk.StringVar(value=self.config.get('network', 'API_URL', fallback=''))
        api_url_entry = ttk.Entry(config_frame, textvariable=self.api_url_var, width=50)
        api_url_entry.grid(row=0, column=1, padx=(10, 0), sticky=(tk.W, tk.E))

        # API Key kh√¥ng hi·ªÉn th·ªã tr√™n UI
        self.api_key_var = tk.StringVar(value=self.config.get('network', 'X_API_KEY', fallback=''))
        
        # Folder path
        ttk.Label(config_frame, text="Th∆∞ m·ª•c Excel:").grid(row=2, column=0, sticky=tk.W, pady=(5, 0))
        folder_frame = ttk.Frame(config_frame)
        folder_frame.grid(row=2, column=1, padx=(10, 0), sticky=(tk.W, tk.E), pady=(5, 0))
        
        self.folder_path_var = tk.StringVar(value=self.config.get('settings', 'EXCEL_FOLDER_PATH', fallback=''))
        folder_entry = ttk.Entry(folder_frame, textvariable=self.folder_path_var, width=40)
        folder_entry.grid(row=0, column=0, sticky=(tk.W, tk.E))
        
        browse_button = ttk.Button(folder_frame, text="Ch·ªçn", command=self.browse_folder)
        browse_button.grid(row=0, column=1, padx=(5, 0))
        
        # Polling interval
        ttk.Label(config_frame, text="Ki·ªÉm tra (gi√¢y):").grid(row=3, column=0, sticky=tk.W, pady=(5, 0))
        self.interval_var = tk.StringVar(value=self.config.get('settings', 'POLLING_INTERVAL', fallback='5'))
        interval_entry = ttk.Entry(config_frame, textvariable=self.interval_var, width=10)
        interval_entry.grid(row=3, column=1, padx=(10, 0), sticky=tk.W, pady=(5, 0))
        
        # Buttons
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=1, column=0, columnspan=2, pady=(0, 10))
        
        self.start_button = ttk.Button(button_frame, text="B·∫Øt ƒë·∫ßu", command=self.start_monitoring)
        self.start_button.grid(row=0, column=0, padx=(0, 5))
        
        self.stop_button = ttk.Button(button_frame, text="D·ª´ng", command=self.stop_monitoring, state=tk.DISABLED)
        self.stop_button.grid(row=0, column=1, padx=(5, 5))
        
        save_config_button = ttk.Button(button_frame, text="L∆∞u c·∫•u h√¨nh", command=self.save_current_config)
        save_config_button.grid(row=0, column=2, padx=(5, 5))
        
        test_api_button = ttk.Button(button_frame, text="Test API", command=self.test_api_connection)
        test_api_button.grid(row=0, column=3, padx=(5, 0))
        
        # Status
        status_frame = ttk.LabelFrame(main_frame, text="Tr·∫°ng th√°i", padding="10")
        status_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))
        
        self.status_var = tk.StringVar(value="Ch·ªù b·∫Øt ƒë·∫ßu...")
        status_label = ttk.Label(status_frame, textvariable=self.status_var)
        status_label.grid(row=0, column=0, sticky=tk.W)
        
        # Th·ªëng k√™
        stats_frame = ttk.Frame(status_frame)
        stats_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(5, 0))
        
        self.stats_var = tk.StringVar(value="File: 0 | Barcode: 0 | L·ªói: 0")
        stats_label = ttk.Label(stats_frame, textvariable=self.stats_var, font=('TkDefaultFont', 8))
        stats_label.grid(row=0, column=0, sticky=tk.W)
        
        # Log
        log_frame = ttk.LabelFrame(main_frame, text="Log", padding="10")
        log_frame.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        self.log_text = scrolledtext.ScrolledText(log_frame, height=15, width=80)
        self.log_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configure grid weights
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        main_frame.rowconfigure(3, weight=1)
        config_frame.columnconfigure(1, weight=1)
        folder_frame.columnconfigure(0, weight=1)
        status_frame.columnconfigure(0, weight=1)
        log_frame.columnconfigure(0, weight=1)
        log_frame.rowconfigure(0, weight=1)
    
    def browse_folder(self):
        """Ch·ªçn th∆∞ m·ª•c ch·ª©a file Excel"""
        folder = filedialog.askdirectory()
        if folder:
            self.folder_path_var.set(folder)
    
    def test_api_connection(self):
        """Test k·∫øt n·ªëi API"""
        def test_in_thread():
            try:
                api_url = self.api_url_var.get().rstrip('/')
                api_key = self.api_key_var.get()
                
                headers = {
                    'X-API-KEY': api_key,
                    'Content-Type': 'application/json'
                }
                
                self.log_message("üîç ƒêang test k·∫øt n·ªëi API...")
                self.log_message(f"URL: {api_url}")
                
                # Test 1: K·∫øt n·ªëi c∆° b·∫£n
                try:
                    response = requests.get(f"{api_url}/health", headers=headers, timeout=5)
                    self.log_message(f"Health check: {response.status_code}")
                except:
                    self.log_message("‚ö†Ô∏è Endpoint /health kh√¥ng c√≥, th·ª≠ endpoints kh√°c...")
                
                # Test 2: Ki·ªÉm tra endpoint models
                try:
                    response = requests.get(f"{api_url}/check_scan_models", headers=headers, timeout=5)
                    self.log_message(f"GET /check_scan_models: {response.status_code}")
                    if response.status_code != 200:
                        self.log_message(f"Response: {response.text[:200]}")
                except Exception as e:
                    self.log_message(f"‚ùå L·ªói test models: {str(e)}")
                
                # Test 3: Ki·ªÉm tra endpoint tmp
                test_data = {
                    'barcode': 'TEST123',
                    'result': 'TEST',
                    'model': 'TEST',
                    'file_name': 'test.xlsx',
                    'datetime': '2025-10-04 12:00:00'
                }
                
                try:
                    response = requests.post(f"{api_url}/check_scans_tmp", headers=headers, json=test_data, timeout=5)
                    self.log_message(f"POST /check_scans_tmp: {response.status_code}")
                    if response.status_code not in [200, 201]:
                        self.log_message(f"Response: {response.text[:200]}")
                    else:
                        self.log_message("‚úÖ API connection OK!")
                except Exception as e:
                    self.log_message(f"‚ùå L·ªói test upload: {str(e)}")
                
                # Test 4: Ki·ªÉm tra c√°c endpoint ph·ªï bi·∫øn kh√°c
                common_endpoints = [
                    "/api/check_scans_tmp",
                    "/check-scans-tmp", 
                    "/scans/tmp",
                    "/upload/barcode"
                ]
                
                self.log_message("üîç Ki·ªÉm tra c√°c endpoint kh√°c:")
                for endpoint in common_endpoints:
                    try:
                        test_url = api_url.replace('/api', '') + endpoint
                        response = requests.post(test_url, headers=headers, json=test_data, timeout=3)
                        self.log_message(f"  {endpoint}: {response.status_code}")
                    except:
                        pass
                        
            except Exception as e:
                self.log_message(f"‚ùå L·ªói test API: {str(e)}")
        
        # Ch·∫°y test trong thread ri√™ng
        thread = threading.Thread(target=test_in_thread, daemon=True)
        thread.start()
    
    def save_current_config(self):
        """L∆∞u c·∫•u h√¨nh hi·ªán t·∫°i"""
        self.config['network']['API_URL'] = self.api_url_var.get()
        self.config['network']['X_API_KEY'] = self.api_key_var.get()
        self.config['settings']['EXCEL_FOLDER_PATH'] = self.folder_path_var.get()
        self.config['settings']['POLLING_INTERVAL'] = self.interval_var.get()
        
        self.save_config()
        self.log_message("ƒê√£ l∆∞u c·∫•u h√¨nh")
    
    def log_message(self, message):
        """Ghi log v√†o text widget"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] {message}\n"
        
        # Update UI in main thread
        self.root.after(0, lambda: self._append_log(log_entry))
    
    def _append_log(self, log_entry):
        """Th√™m log v√†o text widget (ch·∫°y trong main thread)"""
        self.log_text.insert(tk.END, log_entry)
        self.log_text.see(tk.END)
    
    def update_stats(self):
        """C·∫≠p nh·∫≠t th·ªëng k√™"""
        stats_text = f"File: {self.total_files_processed} | Barcode: {self.total_barcodes_uploaded} | L·ªói: {self.total_errors}"
        self.root.after(0, lambda: self.stats_var.set(stats_text))
    
    def update_status(self, status):
        """C·∫≠p nh·∫≠t tr·∫°ng th√°i"""
        self.root.after(0, lambda: self.status_var.set(status))
    
    def start_monitoring(self):
        """B·∫Øt ƒë·∫ßu gi√°m s√°t th∆∞ m·ª•c"""
        if not self.folder_path_var.get():
            messagebox.showerror("L·ªói", "Vui l√≤ng ch·ªçn th∆∞ m·ª•c ch·ª©a file Excel")
            return
        
        if not os.path.exists(self.folder_path_var.get()):
            messagebox.showerror("L·ªói", "Th∆∞ m·ª•c kh√¥ng t·ªìn t·∫°i")
            return
        
        self.save_current_config()
        
        self.is_running = True
        self.start_button.config(state=tk.DISABLED)
        self.stop_button.config(state=tk.NORMAL)
        
        # B·∫Øt ƒë·∫ßu monitoring thread
        self.monitoring_thread = threading.Thread(target=self.monitor_folder, daemon=True)
        self.monitoring_thread.start()
        
        self.update_status("ƒêang gi√°m s√°t...")
        self.log_message("B·∫Øt ƒë·∫ßu gi√°m s√°t th∆∞ m·ª•c: " + self.folder_path_var.get())
    
    def stop_monitoring(self):
        """D·ª´ng gi√°m s√°t"""
        self.is_running = False
        
        if self.observer:
            self.observer.stop()
            self.observer.join()
        
        self.start_button.config(state=tk.NORMAL)
        self.stop_button.config(state=tk.DISABLED)
        
        self.update_status("ƒê√£ d·ª´ng")
        self.log_message("ƒê√£ d·ª´ng gi√°m s√°t")
    
    def monitor_folder(self):
        """Gi√°m s√°t th∆∞ m·ª•c v√† x·ª≠ l√Ω file Excel"""
        folder_path = self.folder_path_var.get()
        interval = int(self.interval_var.get())
        
        # X·ª≠ l√Ω file c√≥ s·∫µn
        self.process_existing_files()
        
        # Thi·∫øt l·∫≠p file watcher
        event_handler = ExcelFileHandler(self)
        self.observer = Observer()
        self.observer.schedule(event_handler, folder_path, recursive=False)
        self.observer.start()
        
        # Polling ƒë·ªÉ ki·ªÉm tra file thay ƒë·ªïi
        while self.is_running:
            try:
                time.sleep(interval)
                if self.is_running:
                    self.check_for_modified_files()
            except Exception as e:
                self.log_message(f"L·ªói monitoring: {str(e)}")
    
    def process_existing_files(self):
        """X·ª≠ l√Ω c√°c file Excel c√≥ s·∫µn trong th∆∞ m·ª•c, ch·ªâ l·∫•y file trong 10 ng√†y g·∫ßn nh·∫•t"""
        folder_path = self.folder_path_var.get()
        current_time = time.time()
        ten_days_ago = current_time - (10 * 24 * 60 * 60)  # 10 ng√†y tr∆∞·ªõc
        
        # L·ªçc file Excel trong 10 ng√†y g·∫ßn nh·∫•t
        excel_files = []
        for filename in os.listdir(folder_path):
            if filename.endswith('.xlsx') or filename.endswith('.xls'):
                file_path = os.path.join(folder_path, filename)
                try:
                    file_mod_time = os.path.getmtime(file_path)
                    if file_mod_time >= ten_days_ago:
                        excel_files.append(filename)
                except:
                    # N·∫øu kh√¥ng ƒë·ªçc ƒë∆∞·ª£c th·ªùi gian file, v·∫´n th√™m v√†o danh s√°ch
                    excel_files.append(filename)
        
        total_files = len(excel_files)
        if total_files == 0:
            self.log_message("üìÇ Kh√¥ng c√≥ file Excel n√†o trong 10 ng√†y g·∫ßn nh·∫•t")
            return
            
        self.log_message(f"üìÇ T√¨m th·∫•y {total_files} file Excel trong 10 ng√†y g·∫ßn nh·∫•t")
        
        for i, filename in enumerate(excel_files, 1):
            file_path = os.path.join(folder_path, filename)
            
            # Ki·ªÉm tra file c√≥ ƒëang ƒë∆∞·ª£c m·ªü hay kh√¥ng
            try:
                with open(file_path, 'rb') as f:
                    pass
                self.process_excel_file(file_path)
                # Gi·∫£m delay xu·ªëng 2 gi√¢y ƒë·ªÉ upload nhanh h∆°n
                time.sleep(2)
            except PermissionError:
                self.log_message(f"‚ö†Ô∏è {filename} - ƒëang ƒë∆∞·ª£c m·ªü, b·ªè qua")
                self.total_errors += 1
            except Exception as e:
                self.log_message(f"‚ùå {filename} - L·ªói: {str(e)}")
                self.total_errors += 1
                # B·ªè qua file l·ªói v√† ti·∫øp t·ª•c
                continue
            
            self.update_stats()
    
    def check_for_modified_files(self):
        """Ki·ªÉm tra file ƒë√£ thay ƒë·ªïi"""
        folder_path = self.folder_path_var.get()
        
        for filename in os.listdir(folder_path):
            if filename.endswith('.xlsx') or filename.endswith('.xls'):
                file_path = os.path.join(folder_path, filename)
                
                # Ki·ªÉm tra th·ªùi gian modify
                mod_time = os.path.getmtime(file_path)
                current_time = time.time()
                
                # N·∫øu file ƒë∆∞·ª£c modify trong 1 ph√∫t qua
                if current_time - mod_time < 60:
                    if file_path not in self.processed_files or mod_time > self.processed_files.get(file_path, 0):
                        self.process_excel_file(file_path)
                        self.processed_files[file_path] = mod_time
    
    def extract_model_from_filename(self, filename):
        """Tr√≠ch xu·∫•t model t·ª´ t√™n file: lo·∫°i b·ªè ph·∫ßn ng√†y th√°ng ·ªü cu·ªëi, v√≠ d·ª• TPRF 40W 36V 5PCB2025-12-03.xlsx => TPRF 40W 36V 5PCB"""
        import re
        base_name = os.path.splitext(filename)[0]
        # Lo·∫°i b·ªè ph·∫ßn ng√†y th√°ng ·ªü cu·ªëi (yyyy-mm-dd ho·∫∑c yyyy-mm-d)
        model_match = re.match(r'(.+?)(\d{4}-\d{2}-\d{2}|\d{4}-\d{2}-\d{1})$', base_name)
        if model_match:
            model_part = model_match.group(1)
        else:
            model_part = base_name
        # N·∫øu c√≥ prefix IPS- th√¨ lo·∫°i b·ªè
        if model_part.startswith('IPS-'):
            model_part = model_part[4:]
        return model_part.strip()
    
    def get_model_from_database(self, extracted_model):
        """So s√°nh to√†n chu·ªói t√™n file v·ªõi code, lu√¥n tr·∫£ v·ªÅ code (t√™n model) khi kh·ªõp"""
        import difflib
        try:
            api_url = self.api_url_var.get().rstrip('/')
            api_key = self.api_key_var.get()
            headers = {
                'X-API-Key': api_key,
                'Content-Type': 'application/json'
            }
            # G·ªçi API l·∫•y danh s√°ch models
            response = requests.get(f"{api_url}/check-scan/models", headers=headers, timeout=10)
            if response.status_code == 200:
                models = response.json()
                if isinstance(models, dict) and 'data' in models and 'models' in models['data']:
                    models = models['data']['models']
                extracted_model_norm = extracted_model.strip().lower().replace(' ', '').replace('_','').replace('-','')
                # T·∫°o danh s√°ch t·∫•t c·∫£ code ƒë√£ chu·∫©n h√≥a
                model_map = []
                for model in models:
                    code = str(model.get('code', '')).strip().lower().replace(' ', '').replace('_','').replace('-','')
                    if code:
                        model_map.append((model.get('code'), code))
                # T√¨m best match b·∫±ng difflib
                if model_map:
                    best = difflib.get_close_matches(extracted_model_norm, [m[1] for m in model_map], n=1, cutoff=0.6)
                    if best:
                        for name, norm in model_map:
                            if norm == best[0]:
                                return name
                return None
            else:
                return None
        except Exception as e:
            return None
    
    def is_valid_barcode(self, cell_value):
        """Ki·ªÉm tra xem gi√° tr·ªã c√≥ ph·∫£i barcode h·ª£p l·ªá kh√¥ng"""
        if not cell_value or str(cell_value).strip() == '':
            return False
            
        cell_str = str(cell_value).strip()
        
        # Debug: log gi√° tr·ªã ƒëang ki·ªÉm tra
        # self.log_message(f"üîç Ki·ªÉm tra: '{cell_str}'")
        
        # B·ªè qua n·∫øu l√† NaN ho·∫∑c None
        if cell_str.lower() in ['nan', 'none', 'null', '']:
            return False
        
        # B·ªè qua n·∫øu l√† ng√†y th√°ng v·ªõi format kh√°c nhau
        if ('/' in cell_str or '-' in cell_str or ':' in cell_str) and any(c.isdigit() for c in cell_str):
            import re
            # Ki·ªÉm tra nhi·ªÅu format ng√†y th√°ng
            date_patterns = [
                r'\d{4}-\d{2}-\d{2}',           # 2025-10-04
                r'\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2}',  # 2025-10-04 02:13:59
                r'\d{1,2}[/-]\d{1,2}[/-]\d{2,4}',         # 10/04/2025
                r'\d{4}[/-]\d{1,2}[/-]\d{1,2}',           # 2025/10/04
                r'\d{2}:\d{2}:\d{2}',                     # 02:13:59
                r'\d{1,2}:\d{1,2}'                        # 2:13
            ]
            for pattern in date_patterns:
                if re.search(pattern, cell_str):
                    return False
        
        # B·ªè qua c√°c t·ª´ kh√≥a sai - m·ªü r·ªông danh s√°ch
        invalid_keywords = [
            'no', 'ng', 'yes', 'ok', 'on', 'off', 'error', 'test', 'sample', 
            'header', 'title', 'barcode', 'sheet', 'pass', 'fail', 'null',
            '‰∫åÁª¥Á†Å', 'ÊµãËØïÊó∂Èó¥', 'ÊµãËØïÁªìÊûú'  # Th√™m t·ª´ kh√≥a ti·∫øng Trung
        ]
        if any(keyword == cell_str.lower() for keyword in invalid_keywords):
            return False
        
        # B·ªè qua n·∫øu ch·ª©a t·ª´ kh√≥a ti·∫øng Trung
        chinese_keywords = ['‰∫åÁª¥Á†Å', 'ÊµãËØï', 'ÁªìÊûú', 'Êó∂Èó¥']
        if any(keyword in cell_str for keyword in chinese_keywords):
            return False
        
        # B·ªè qua n·∫øu ch·ªâ to√†n s·ªë ho·∫∑c to√†n ch·ªØ
        if cell_str.isdigit() or cell_str.isalpha():
            return False
        
        # B·ªè qua n·∫øu l√† s·ªë th·∫≠p ph√¢n ƒë∆°n thu·∫ßn (nh∆∞ 33.60, 220.0, 29.69)
        try:
            float_val = float(cell_str)
            if '.' in cell_str and len(cell_str.split('.')) == 2:
                # N·∫øu l√† s·ªë th·∫≠p ph√¢n c√≥ √≠t h∆°n 6 k√Ω t·ª± th√¨ b·ªè qua
                if len(cell_str.replace('.', '')) < 6:
                    return False
        except:
            pass
        
        # B·ªè qua n·∫øu qu√° ng·∫Øn
        if len(cell_str) < 8:
            return False
        
        # B·ªè qua n·∫øu c√≥ qu√° nhi·ªÅu k√Ω t·ª± ƒë·∫∑c bi·ªát
        special_chars = sum(1 for c in cell_str if not c.isalnum())
        if special_chars > len(cell_str) * 0.3:
            return False
        
        # Barcode h·ª£p l·ªá ph·∫£i c√≥ c·∫£ s·ªë v√† ch·ªØ, v√† ƒë·ªß d√†i
        has_digit = any(c.isdigit() for c in cell_str)
        has_alpha = any(c.isalpha() for c in cell_str)
        
        return (has_digit and has_alpha and len(cell_str) >= 8)

    def create_clean_excel_file(self, file_path):
        """T·∫°o file Excel s·∫°ch ch·ªâ ch·ª©a c√°c d√≤ng c√≥ barcode h·ª£p l·ªá v√† ƒë·ªãnh d·∫°ng gi·ªëng s·ªë ƒë√¥ng"""
        import tempfile
        import os
        from collections import Counter
        filename = os.path.basename(file_path)
        temp_file = None
        try:
            excel_file = pd.ExcelFile(file_path)
            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.xlsx')
            temp_file.close()
            with pd.ExcelWriter(temp_file.name, engine='openpyxl') as writer:
                total_rows = 0
                valid_rows = 0
                for sheet_name in excel_file.sheet_names:
                    try:
                        df = pd.read_excel(file_path, sheet_name=sheet_name, header=0, engine='openpyxl')
                        df_clean = df.dropna(how='all')
                        if len(df_clean) > 0:
                            total_rows += len(df_clean)
                            # L·ªçc c√°c d√≤ng c√≥ barcode h·ª£p l·ªá
                            valid_rows_list = []
                            row_lengths = []
                            for idx, row in df_clean.iterrows():
                                has_valid_barcode = False
                                for col_idx in range(min(8, len(row))):
                                    if self.is_valid_barcode(row.iloc[col_idx]):
                                        has_valid_barcode = True
                                        break
                                if has_valid_barcode:
                                    valid_rows_list.append(row)
                                    row_lengths.append(len(row.dropna()))
                            # Ch·ªâ gi·ªØ c√°c d√≤ng c√≥ s·ªë l∆∞·ª£ng c·ªôt gi·ªëng s·ªë ƒë√¥ng
                            if valid_rows_list:
                                # T√¨m s·ªë l∆∞·ª£ng c·ªôt ph·ªï bi·∫øn nh·∫•t
                                if row_lengths:
                                    majority_len = Counter(row_lengths).most_common(1)[0][0]
                                    filtered_rows = [row for row, rlen in zip(valid_rows_list, row_lengths) if len(row.dropna()) == majority_len]
                                else:
                                    filtered_rows = valid_rows_list
                                if filtered_rows:
                                    clean_df = pd.DataFrame(filtered_rows)
                                    clean_df.to_excel(writer, sheet_name=sheet_name, index=False)
                                    valid_rows += len(clean_df)
                    except Exception as sheet_error:
                        self.log_message(f"‚ùå L·ªói ƒë·ªçc sheet '{sheet_name}': {str(sheet_error)}")
                        continue
                if valid_rows == 0:
                    self.log_message(f"‚ö†Ô∏è {filename} kh√¥ng c√≥ d√≤ng barcode h·ª£p l·ªá n√†o")
                    if os.path.exists(temp_file.name):
                        os.unlink(temp_file.name)
                    return None, 0, 0
                self.log_message(f"üìä {filename}: {valid_rows}/{total_rows} d√≤ng h·ª£p l·ªá s·∫Ω ƒë∆∞·ª£c upload")
                return temp_file.name, valid_rows, total_rows
        except Exception as e:
            self.log_message(f"‚ùå L·ªói t·∫°o file s·∫°ch cho {filename}: {str(e)}")
            if temp_file and os.path.exists(temp_file.name):
                os.unlink(temp_file.name)
            return None, 0, 0

    def process_excel_file(self, file_path):
        """Upload file Excel ƒë√£ ƒë∆∞·ª£c l·ªçc s·∫°ch l√™n API"""
        filename = os.path.basename(file_path)
        temp_file = None
        
        try:
            # T·∫°o file Excel s·∫°ch
            temp_file, valid_rows, total_rows = self.create_clean_excel_file(file_path)
            
            if temp_file is None or valid_rows == 0:
                self.total_errors += 1
                return False
            
            # L·∫•y model t·ª´ t√™n file
            extracted_model = self.extract_model_from_filename(filename)
            model = self.get_model_from_database(extracted_model)
            if model is None or str(model).strip() == '':
                model = 'NULL'
            
            api_url = self.api_url_var.get().rstrip('/')
            api_key = self.api_key_var.get()
            headers = {'X-API-Key': api_key}
            
            # Upload file s·∫°ch v·ªõi retry - QUAN TR·ªåNG: d√πng temp_file (file ƒë√£ l·ªçc)
            max_retries = 3
            retry_delay = 3
            
            for attempt in range(max_retries):
                try:
                    # ƒê√ÇY L√Ä ƒêI·ªÇM QUAN TR·ªåNG: Upload temp_file (file s·∫°ch) nh∆∞ng v·ªõi t√™n file g·ªëc
                    with open(temp_file, 'rb') as file_handle:
                        files = {
                            'scans[0][file]': (filename, file_handle, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
                        }
                        data = {'scans[0][model]': model}
                        
                        self.log_message(f"üì§ Uploading file s·∫°ch v·ªõi {valid_rows} d√≤ng h·ª£p l·ªá...")
                        response = requests.post(f"{api_url}/check-scan/upload-file", headers=headers, files=files, data=data, timeout=60)
                    
                    if response.status_code in [200, 201]:
                        self.log_message(f"‚úÖ {filename} ({model}) - Upload {valid_rows} d√≤ng th√†nh c√¥ng")
                        self.total_files_processed += 1
                        return True
                        
                    elif response.status_code == 500:
                        if attempt < max_retries - 1:
                            self.log_message(f"‚è≥ Server l·ªói 500, th·ª≠ l·∫°i l·∫ßn {attempt + 2}...")
                            time.sleep(retry_delay)
                            continue
                        else:
                            self.log_message(f"‚ùå {filename} ({model}) - Server l·ªói (500) sau {max_retries} l·∫ßn th·ª≠")
                            self.total_errors += 1
                            return False
                            
                    elif response.status_code == 422:
                        self.log_message(f"‚ùå {filename} ({model}) - L·ªói format file (422)")
                        self.total_errors += 1
                        return False
                        
                    else:
                        self.log_message(f"‚ùå {filename} ({model}) - L·ªói upload ({response.status_code})")
                        self.total_errors += 1
                        return False
                        
                except requests.exceptions.Timeout:
                    if attempt < max_retries - 1:
                        self.log_message(f"‚è≥ {filename} - Timeout, th·ª≠ l·∫°i l·∫ßn {attempt + 2}...")
                        time.sleep(retry_delay)
                        continue
                    else:
                        self.log_message(f"‚ùå {filename} ({model}) - Timeout sau {max_retries} l·∫ßn th·ª≠")
                        self.total_errors += 1
                        return False
                        
                except requests.exceptions.ConnectionError:
                    if attempt < max_retries - 1:
                        self.log_message(f"üîÑ {filename} - M·∫•t k·∫øt n·ªëi, th·ª≠ l·∫°i l·∫ßn {attempt + 2}...")
                        time.sleep(retry_delay)
                        continue
                    else:
                        self.log_message(f"‚ùå {filename} ({model}) - L·ªói k·∫øt n·ªëi")
                        self.total_errors += 1
                        return False
                        
        except Exception as e:
            self.log_message(f"‚ùå {filename} - L·ªói x·ª≠ l√Ω: {str(e)}")
            self.total_errors += 1
            return False
            
        finally:
            # X√≥a file t·∫°m th·ªùi
            if temp_file and os.path.exists(temp_file):
                try:
                    os.unlink(temp_file)
                    self.log_message(f"üóëÔ∏è ƒê√£ x√≥a file t·∫°m th·ªùi")
                except:
                    pass
    
    def process_tmp_to_main_table(self):
        """X·ª≠ l√Ω d·ªØ li·ªáu t·ª´ b·∫£ng tmp sang b·∫£ng ch√≠nh"""
        try:
            api_url = self.api_url_var.get()
            api_key = self.api_key_var.get()
            headers = {
                'X-API-Key': api_key
            }
            # G·ªçi API ƒë·ªÉ x·ª≠ l√Ω d·ªØ li·ªáu
            response = requests.post(
                f"{api_url}/process_tmp_to_main",
                headers=headers,
                timeout=30
            )
            if response.status_code in [200, 201]:
                self.log_message("‚úÖ ƒê√£ x·ª≠ l√Ω d·ªØ li·ªáu t·ª´ tmp sang b·∫£ng ch√≠nh th√†nh c√¥ng")
                try:
                    result = response.json()
                    if 'processed_count' in result:
                        self.log_message(f"üìä S·ªë b·∫£n ghi ƒë√£ x·ª≠ l√Ω: {result['processed_count']}")
                    if 'duplicates_removed' in result:
                        self.log_message(f"üóëÔ∏è S·ªë b·∫£n ghi tr√πng l·∫∑p ƒë√£ lo·∫°i b·ªè: {result['duplicates_removed']}")
                except:
                    pass
            else:
                self.log_message(f"‚ùå L·ªói x·ª≠ l√Ω tmp->main: {response.status_code}")
        except Exception as e:
            self.log_message(f"‚ùå L·ªói x·ª≠ l√Ω tmp->main: {str(e)}")


class ExcelFileHandler(FileSystemEventHandler):
    """Handler cho file system events"""
    
    def __init__(self, app):
        self.app = app
    
    def on_modified(self, event):
        """X·ª≠ l√Ω khi file ƒë∆∞·ª£c modify"""
        if not event.is_directory and (event.src_path.endswith('.xlsx') or event.src_path.endswith('.xls')):
            # ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ file ƒë∆∞·ª£c ghi ho√†n to√†n
            time.sleep(2)
            self.app.process_excel_file(event.src_path)
    
    def on_created(self, event):
        """X·ª≠ l√Ω khi file m·ªõi ƒë∆∞·ª£c t·∫°o"""
        if not event.is_directory and (event.src_path.endswith('.xlsx') or event.src_path.endswith('.xls')):
            # ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ file ƒë∆∞·ª£c ghi ho√†n to√†n
            time.sleep(2)
            self.app.process_excel_file(event.src_path)


def main():
    root = tk.Tk()
    import os
    icon_path = os.path.join(os.path.dirname(__file__), 'readexcel.ico')
    if os.path.exists(icon_path):
        try:
            root.iconbitmap(icon_path)
        except Exception:
            pass
    app = ExcelToDBApp(root)
    root.mainloop()


if __name__ == "__main__":
    main()